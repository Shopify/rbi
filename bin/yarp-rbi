#!/usr/bin/env ruby
# typed: strict
# frozen_string_literal: true

require "bundler"
Bundler.setup

require "rbi"
require "yaml"

YARP_GEM = "yarp"
YARP_CONFIG = "config.yml"

RBI_HEADER = T.let(<<~RBI, String)
  # typed: true

  # DO NOT EDIT MANUALLY
  # This is an autogenerated file for YARP, run `bin/yarp-rbi` instead.

  module YARP
    class << self
      # Mirror the YARP.parse API by using the serialization API.
      sig { params(arg: String).returns(YARP::ParseResult)}
      def parse(*arg); end

      # Mirror the YARP.parse_file API by using the serialization API. This uses
      # native strings instead of Ruby strings because it allows us to use mmap when
      # it is available.
      sig { params(path: String).returns(YARP::ParseResult)}
      def parse_file(path); end
    end
  end

  # This represents the result of a call to ::parse or ::parse_file. It contains
  # the AST, any comments that were encounters, and any errors that were
  # encountered.
  class YARP::ParseResult
    # Returns the value of attribute comments.
    sig { returns(T::Array[YARP::Comment]) }
    def comments; end

    # Returns the value of attribute errors.
    sig { returns(T::Array[YARP::ParseError]) }
    def errors; end

    sig { returns(T::Boolean) }
    def failure?; end

    # Returns the value of attribute source.
    sig { returns(String) }
    def source; end

    sig { returns(T::Boolean) }
    def success?; end

    # Returns the value of attribute value.
    sig { returns(YARP::Node) }
    def value; end

    # Returns the value of attribute warnings.
    sig { returns(T::Array[YARP::ParseWarning]) }
    def warnings; end
  end
RBI

class RBIGenerator
  extend T::Sig

  sig { void }
  def generate
    csv = load_config
    rbi = compile_config(csv)

    puts RBI_HEADER
    puts rbi.string
  end

  private

  sig { returns(T::Hash[String, T.untyped]) }
  def load_config
    yarp_gem = Gem::Specification.find_by_name(YARP_GEM)
    yarp_path = yarp_gem.full_gem_path
    config_path = File.join(yarp_path, YARP_CONFIG)
    yaml = YAML.load_file(config_path)

    unless yaml.is_a?(Hash)
      warn("Could not parse config.yml in yarp gem")
      exit(1)
    end

    yaml
  rescue Gem::MissingSpecError => e
    warn("Could not find yarp gem (#{e})")
    exit(1)
  rescue Errno::ENOENT => e
    warn("Could not find config.yml in yarp gem (#{e})")
    exit(1)
  end

  sig { params(config: T::Hash[String, T.untyped]).returns(RBI::File) }
  def compile_config(config)
    rbi = RBI::File.new

    config["nodes"].each do |node|
      rbi << RBI::Class.new("YARP::#{node["name"]}") do |klass|
        comment = node["comment"]
        klass.comments << RBI::Comment.new(comment) if comment

        node["fields"]&.each do |field|
          type = translate_type(field["type"])
          klass << RBI::AttrReader.new(
            field["name"].to_sym,
            sigs: [RBI::Sig.new(return_type: type)],
          )
        end
      end
    end

    rbi
  end

  sig { params(type: String).returns(String) }
  def translate_type(type)
    is_nilable = T.let(false, T::Boolean)
    is_array = T.let(false, T::Boolean)

    type = case type
    when /.*\?/
      is_nilable = true
      type.delete_suffix("?")
    when /.*\[\]/
      is_array = true
      type.delete_suffix("[]")
    else
      type
    end

    type = case type
    when /^flags/
      "Integer"
    when /^string/
      "String"
    when /^uint32/
      "Integer"
    when /^constant/
      "Symbol"
    else
      "YARP::#{type.capitalize}"
    end

    if is_nilable
      "T.nilable(#{type})"
    elsif is_array
      "T::Array[#{type}]"
    else
      type
    end
  end
end

RBIGenerator.new.generate
